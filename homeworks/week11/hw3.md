## 請說明雜湊跟加密的差別在哪裡，為什麼密碼要雜湊過後才存入資料庫
*****
加密是一對一的關係，也就是說只要知道了解密的方法，就能夠把加密後的密碼還原成原來的密碼，是可逆的；雜湊就不可逆了，他無法還原已經被雜湊計算過後的密碼，所以相對加密來說更加安全。  
而密碼透過雜湊存入資料庫裡的話，就算某天駭客偷走了資料庫的資料，他也無法得知 user 的密碼為何。

## `include`、`require`、`include_once`、`require_once` 的差別
*****
- Require, Require_once( )  
require 語法通常放在 php 程式的最前面，php 程式在執行前，就會先讀入 require 所指定引入的檔案，使它變成 php 程式網頁的一部份。常用的函式可以寫成一個函式庫檔案，然後用這個方法將它引入網頁中。  
require_once 的作用和 require 是幾乎相同的，唯一的差別在於 require_once 會先檢查要引入的檔案是不是已經在該程式中的其他地方被引入過了；如果有的話，就不會再次重複引入該檔案。這項功能有時候是很重要的，比方說要引入的檔案裡面宣告了一些我們自行定義的函數，那麼如果在同一個程式重複引入這個檔案，在第二次引入的時候便會發生錯誤訊息，因為 php 不允許相同名稱的函數被重複宣告。  
<br>
- include 及 include_once( )  
include 語法一般是放在流程控制的處理區段中。php 程式網頁在讀到 include 的檔案時，才將它讀進來。這種方式，可以把程式執行時的流程簡單化。
如同 require_once，include_once 會先檢查欲引入檔案的內容是不是在之前就已經引入過了；如果是的話，便不會再次重複引入同樣的內容。  
<br>
- require和include的不同  
include在執行時，如果include進來的檔案發生錯誤的話，會顯示警告，不會立刻停止；
而require 則是會顯示錯誤，立刻終止程式，不再往下執行。
include可以用在迴圈；require不行。

## 請說明 SQL Injection 的攻擊原理以及防範方法
*****
如果程式碼中 SQL 的指令只是單純的字串加上使用者輸入的資料，則使用者可以透過在 SQL 的字串中塞入更改 SQL 語句的惡意字串，偷走資料庫的資料，或是攻擊資料庫，這邊借用維基百科的例子：  
某個網站登入驗證的SQL查詢代碼為

`strSQL = "SELECT * FROM users WHERE (name = '" + userName + "') and (pw = '"+ passWord +"');"`

惡意填入

`userName = "1' OR '1'='1";`  

與  

`passWord = "1' OR '1'='1";`  

時，將導致原本的SQL字串被填為

`strSQL = "SELECT * FROM users WHERE (name = '1' OR '1'='1') and (pw = '1' OR '1'='1');"`

也就是實際上執行的SQL命令會變成下面這樣的

`strSQL = "SELECT * FROM users;"`  

因此達到無帳號密碼，亦可登入網站。所以 SQL Injection 被俗稱為駭客的填空遊戲。  
如要加以防範，以 php 來說，可以透過內建的 Prepared statement 功能，讓內建的程式自動去做字串的拼接，阻止使用者以注入的方式更改 SQL 的指令。

##  請說明 XSS 的攻擊原理以及防範方法
*****
  XSS 攻擊通常最常發生在 input 讓使用者可以輸入的地方，因為使用者輸入的內容被當成程式碼解讀，而使用者可以透過安插惡意程式碼的方式，將網頁導向惡意、釣魚網站，或是竊取網頁的資料或其他資訊，造成網頁的安全漏洞。  
  如果要防範 XSS 攻擊，則要避免使用者輸入的內容被當成程式碼，必須讓使用者輸入的內容變成單純的純文字，例如以 php 來說的話，可以透過 htmlspecialchars 這個 function 來轉換，變成單純的純文字。

## 請說明 CSRF 的攻擊原理以及防範方法
*****
大部分的網站都是採用 cookie 或 session 的方式進行登入驗證，當通過登入驗證之後，網站就會給你一個通行證存在 cookie 或 session 中，代表之後的動作中都不需要重複驗證身分了。但 CSRF 的攻擊正是鑽了這個機制的漏洞來達到攻擊的目的。  
- 簡單白話的舉例：  
  
  想像 cookie 就像是每個人身上的筆記本，當你在A銀行登入之後，A銀行在你的筆記本上蓋了個印章，有這個印章之後，接下來三個小時內你的所有動作都不需要重複驗證身分。但你在這三小時內又跑去逛了其他網頁，很不巧的就逛到了駭客B架設的惡意網頁，這個惡意網頁偷偷複製了你的 cookie 筆記本的印章，跑去打A銀行的轉帳API，請A銀行把你的存款匯10萬元到駭客B自己的帳戶，由於A銀行認印章不認人，所以就接受了這筆匯款請求。
  所以只是登入了A銀行的帳戶，同時逛逛網拍、找找資料，突然間就損失了10萬塊！
- 防範方法：  
  
  - 使用者端：CSRF 攻擊是透過使用者處於已經登入的狀態，做出一些行為。如果使用者想要加以防範 CSRF 攻擊，可以在每次使用完網站就登出，就可以避免掉 CSRF。  
  - Server端：  
    1. 加上圖形驗證碼：像是平常網路銀行轉帳一樣，都會要你收簡訊驗證碼，多了這一道檢查就可以確保不會被 CSRF 攻擊。圖形驗證碼也是，攻擊者並不知道圖形驗證碼的答案是什麼，所以就不可能攻擊了。
      
    2. 加上 CSRF token：只要使用者能提出一個唯一且保密的序號，攻擊者拿不到這個序號，自然就不能偽裝成使用者，而這個序號，就是 CSRF Token，這個 Token 是由server 產生，並且加密存在 session 中，其他人無法仿造，只有透過 server 給使用者，並在一定時間內刷新。當使用者想做任何交易的時候，server 就會請使用者提供CSRF Token，如果不能提供，那 server 就不予理會。但這種方法如果有一個狀況是，假設 server 支持 cross origin 的 request，攻擊者就可以在他的頁面發起一個 request，順利拿到這個 csrf token 並且進行攻擊。
      
    3. Double Submit Cookie：相較第二種解法 ->  csrf token 必須被保存在 server 當中，此種解法的好處是完全不需要 server 儲存東西。  
    這種解法和第二種有點類似，由 server 產生一組隨機的 token 並且加在 form 上面。但不同的點在於，除了不用把這個值寫在 session 以外，同時也讓 client 端設定一個名叫 csrftoken 的 cookie，值也是同一組 token。當使用者按下 submit 的時候，server 比對 cookie 內的 csrftoken 與 form 裡面的 csrftoken，檢查是否有值並且相等，就知道是不是使用者發的了。